# Cursor 相关

在重度使用 Cursor 几个月后，我也算有了几点心得，下面就来详细说下

## 一些心得

### 缩小变更范围，不要试图一次做太多

### 让 cursor 复述你的要求

我们陈述语言是有模糊性的，加上 ai 理解特定信息的局限性，以及 ai 生成内容的随机性，有些时候我们可能会遇到 ai”答非所问“的情况，这个时候别怪 ai，应该先看下自己的提问或描述是否清晰易懂，最好的方法就是让 ai 复述一遍你的需求，看 ai 是否充分理解了。

### 善用图示提问

如果你的需求是否很难用文字完全描述清楚，可以适当增加一些图示，这样能更好地帮助 cursor 去理解你的意图

### 先 save 再 accept

大家其实不用那么着急着去点 accept all，因为你也不知道 cursor 每次生成的代码是不是正确的，更高效率的方式去先点 save all，验证无误后再点 acce all，整个效率会高很多，当然如果你不小心点到了 accept all，也可以用前面的 checkpoint 进行恢复

### C 使用 Ask 模式制定计划，使用 Agent 模式实施计划

cursor 有 Chat 和 Composer 两种模式，我的方法是一般就是先用 Chat 模式和 cursor 沟通好整体的产品架构、技术栈等细节，形成相对成熟的方案后再放到 Ccomposer 模式去沟通，这样效率更高。这是因为两者的侧重点不同：

Chat 模式：主要用于和 cursor 对话，你可以问它有关代码的问题，获取即时的反馈和建议。

它的特点就是互动性强，适合快速解决问题；适合处理具体的代码问题或获取代码片段。想象你在一个虚拟的编程论坛上，向一个智能助手提问。你输入：“如何在 JavaScript 中创建一个数组？”助手立即回复：

const myArray = [1, 2, 3, 4, 5];
然后你继续问：“如何添加一个元素到数组中？”助手又给出答案：

myArray.push(6);
在这个模式下，你可以快速获得代码示例和解决方案，适合快速学习和解决具体问题。但如果你想将这些代码应用到实际开发中，就需要自己创建好文件并一个个复制粘贴过去。

Composer 模式：更侧重于代码的撰写和编辑，你可以在这个模式下进行长篇代码的编写、更改。区别于 Chat，Composer 生成的代码是会帮你直接弄到文件里了，不用复制粘贴。

它的特点就是提供了 checkpoint（代码回滚）、iterate on lints（代码检查修复）等更多的编辑工具，适合撰写完整的代码文件；支持代码的组织和结构化，适合大型项目的开发。

想象你在一个代码编辑器中，正在撰写一个完整的 JavaScript 应用程序。你可以在 Composer 模式下输入多个函数、类和模块，像这样：

// 定义一个简单的函数
function greet(name) {
return Hello, ${name}!;
}
// 使用函数
console.log(greet('World'));
在这个模式下，你可以使用代码高亮、自动补全和格式化工具，方便地组织和管理代码，适合进行复杂的开发工作。

### 经常创建新的对话

（之前在知识星球也分享过，每次完成一个新功能，最好新开对话，避免之前的上下文对后面的功能开发造成污染

## Cursor 锁区问题

在 2025 年 的 7 月份，Cursor 中断了中国大陆用户的多个模型使用权。我们常使用几个模型比如 Claude 系列、Gemini 系列，在国内都无法使用。

[](./images//cursorError.png)

### 为什么会这样

老实说，这次的锁区事件其实跟 Cursor 关系并不大，Cursor 作为一个 AI+IDE 编辑器，他自身其实并不开发模型，它是基于 VSCode​ 开源代码进行开发，再通过他的网络去调用如：Claude、ChatGPT、Gemini 等等这些模型，去使用的模型的能力。

Cursor 也在他的公告里为自己喊冤：

Some models in Cursor may be unavailable in certain regions based on the terms and policies set by the model providers. We plan to re‑enable all models in any regions where they are supported. If our model partners allow access to your region, we plan to restore the affected models and update this page.

大概意思就是，这种限制并非 Cursor 故意为之，而是受到上游模型提供商政策变化的影响。类似的情况在 AI 行业并不罕见， [Anthropic（Claude）](https://docs.anthropic.com/en/api/supported-regions)、[OpenAI（GPT / o‑series）](https://help.openai.com/zh-hans-cn/articles/5347006-openai-api-supported-countries-and-territories)、[Google（Gemini）](https://ai.google.dev/gemini-api/docs/available-regions?hl=zh-cn)等公司都有自己的不支持国家和地区。遗憾的是，中国大陆地区都在这三家公司的封禁名单中...即使是翻墙也不行

### 怎么办？

Cursor 官方给了几个方案

1. 勾选 Auto 选项，每次请求时自动选择可用模型。
2. 如果你有能在当地正常使用的 API key，可以在 Cursor 中配置他，这样就可以绕过去限制。
3. 申请按比例退款

这三种方案其实都没有真正解决问题。官方相当于直接摆烂了，直接告诉国内用户：我也没办法了，您要不勉强用，要不直接退款吧。

真实情况也是如此——在 Cursor 的锁区事件后，大批量的中国用户放弃使用 Cursor，转而使用 Trae、Windsurf 等替代品。那段时间我也放弃 Cursor 去试用了下 Trae，但是使用了一段时间后，它着实令我有点失望，生成的代码常常驴头不对马嘴，智能型这方面还是不如 Cursor，于是我又回到了 Cursor 的怀抱...

锁区的问题还是得解决，民间社区中也有人逐渐摸索出了解决方案：

1. 修改网络类型：ctrl + shift + j 打开控制面板后，点击 Network，修改 http 模式，把默认的 HTTP/2 修改为 HTTP/1.1
   [](./images/cursor-network.png)
2. 在你的代理工具中，将 Tun Mode 打开 [](./images/clash-tun-mode.png)

我实际测试了下，效果还行，常用的几个模型都能使用，就是链接有时候会中断，应该是我的代理不太稳定的问题。

社区中也有人使用 Proxifier 转发 api2.cursor.sh:443​ 来实现，这样既可以使用 http2 享受低延迟，也可以用上 claude 等模型，感兴趣的朋友可以去尝试下。

一顿操作下来也是够麻烦，使用体验还没有以前好。这此的锁区事件本质上还是受美国 AI 出口管制以及国家安全相关政策的影响，受中美技术竞争的影响，也不知道什么技术开发化才能真正到来，让锁区不再成为开发者的一个门槛。同时也望国内的相关公司支棱起来，能够开发出质量更好些、更好用的 AI 编辑器。

## Rules

想要用好 AI 编辑器，rules 肯定是不能绕过去的，合理的 rules 能够提供明确的结构化指导来约束 AI 的行为，并且有效对抗“AI”幻觉，确保生成的代码符合项目标准。

当前 Cursor 有三种类型规则

1. 项目规则：存储在 .cursor/rules 中，受版本控制，作用范围限定在你的代码库内
2. 用户规则：在整个 Cursor 环境中全局生效，由 Agent（Chat）使用
3. AGENTS.md：以 Markdown 格式编写的 Agent 指令，是 .cursor/rules 的简洁替代方案（一般来说很少使用）。

旧版本的.cursorrules 规则文件已经被废弃，当前我还是更推荐写在 .cursor/rules 中的项目规则。

不同于面向全部项目生效的用户规则配置这么简单，项目规则需要根据不同类型的开发项目进行针对性撰写，尤其是其中的角色定位、技术栈选择、代码规范等要求，rules 要想写全写好，还真不是个简单事。为此，我的想法是——先找到一个通用的 rules 模板，然后 AI 编辑器中让 AI 分析当前项目的同事，结合我们之前给定的 rules 模板，生成一个符合我们当前项目要求的 rules。我当前使用 rules 模板如下：

```
角色
你是一名精通  开发的高级工程师，拥有10年以上的  应用开发经验，熟悉  等开发工具和技术栈。你的任务是帮助用户设计和开发易用且易于维护的  应用。始终遵循最佳实践，并坚持干净代码和健壮架构的原则。
目标
你的目标是以用户容易理解的方式帮助他们完成  应用的设计和开发工作，确保应用功能完善、性能优异、用户体验良好。
要求
在理解用户需求、设计UI、编写代码、解决问题和项目迭代优化时，你应该始终遵循以下原则：
项目初始化

在项目开始时，首先仔细阅读项目目录下的 README.md文件并理解其内容，包括项目的目标、功能架构、技术栈和开发计划，确保对项目的整体架构和实现方式有清晰的认识；

如果还没有README.md文件，请主动创建一个，用于后续记录该应用的功能模块、页面结构、数据流、依赖库等信息。
需求理解

充分理解用户需求，站在用户角度思考，分析需求是否存在缺漏，并与用户讨论完善需求；

选择最简单的解决方案来满足用户需求，避免过度设计。
UI和样式设计

使用现代UI框架进行样式设计（例如*，这里可以根据不同开发项目仔细展开，比如使用哪些视觉规范或者UI框架，没有的话也可以不用过多展开）；

在不同平台上实现一致的设计和响应式模式
代码编写

技术选型：根据项目需求选择合适的技术栈（例如*，这里需要仔细展开，比如介绍某个技术栈用在什么地方，以及要遵循什么最佳实践）

代码结构：强调代码的清晰性、模块化、可维护性，遵循最佳实践（如DRY原则、最小权限原则、响应式设计等）

代码安全性：在编写代码时，始终考虑安全性，避免引入漏洞，确保用户输入的安全处理

性能优化：优化代码的性能，减少资源占用，提升加载速度，确保项目的高效运行

测试与文档：编写单元测试，确保代码的健壮性，并提供清晰的中文注释和文档，方便后续阅读和维护

问题解决

全面阅读相关代码，理解 * 应用的工作原理

根据用户的反馈分析问题的原因，提出解决问题的思路

确保每次代码变更不会破坏现有功能，且尽可能保持最小的改动
迭代优化

与用户保持密切沟通，根据反馈调整功能和设计，确保应用符合用户需求

在不确定需求时，主动询问用户以澄清需求或技术细节

每次迭代都需要更新README.md文件，包括功能说明和优化建议
方法论

系统2思维：以分析严谨的方式解决问题。将需求分解为更小、可管理的部分，并在实施前仔细考虑每一步

思维树：评估多种可能的解决方案及其后果。使用结构化的方法探索不同的路径，并选择最优的解决方案

迭代改进：在最终确定代码之前，考虑改进、边缘情况和优化。通过潜在增强的迭代，确保最终解决方案是健壮的
```

## 什么时候该选择什么模型

应该是根据不同场景使用不同的模型。当然，每个人的编码体验可能有所差别

使用 Claude sonnet 3.5 进行编码（是的，对于执行代码来说，它比 3.7 更好。）
使用 GPT o1/o3-mini-high 调试复杂错误。
使用 Gemini Flash 2.0 扫描整个代码库并更新文档

## MCP

### 是什么

MCP 是一种开放协议，它标准化了应用程序向 LLM 提供上下文的方式。可以将 MCP 视为 AI 应用程序的 USB-C 端口。正如 USB-C 提供了一种将设备连接到各种外围设备和配件的标准化方式一样，MCP 提供了一种将 AI 模型连接到不同数据源和工具的标准化方式。（MCP 的全称是 Model Context Protocol，是一个开放协议，它使  LLM  应用与外部数据源和工具之间的无缝集成成为可能。无论你是构建 AI 驱动的  IDE、改善  chat 交互，还是构建自定义的  AI 工作流，MCP 提供了一种标准化的方式，将 LLM 与它们所需的上下文连接起来。
