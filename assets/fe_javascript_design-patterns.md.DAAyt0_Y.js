import{_ as t,E as i,c as s,o as r,j as a,I as c,am as o,a as p}from"./chunks/framework.pKienSF_.js";const j=JSON.parse(`{"title":"Javascript 设计模式与开发实践","description":"","frontmatter":{"head":[["script",{"charset":"UTF-8","id":"LA_COLLECT","src":"//sdk.51.la/js-sdk-pro.min.js"}],["script",{},"typeof LA !== 'undefined' && LA.init({\\"id\\":\\"3LNfUkScYzEz6k4D\\",\\"ck\\":\\"3LNfUkScYzEz6k4D\\",\\"hashMode\\":true})"]]},"headers":[],"relativePath":"fe/javascript/design-patterns.md","filePath":"fe/javascript/design-patterns.md","lastUpdated":1758793222000}`),l={name:"fe/javascript/design-patterns.md"},n=a("h1",{id:"javascript-设计模式与开发实践",tabindex:"-1"},[p("Javascript 设计模式与开发实践 "),a("a",{class:"header-anchor",href:"#javascript-设计模式与开发实践","aria-label":'Permalink to "Javascript 设计模式与开发实践"'},"​")],-1),d=o('<h2 id="前言" tabindex="-1">前言 <a class="header-anchor" href="#前言" aria-label="Permalink to &quot;前言&quot;">​</a></h2><p>设计模式并非是软件开发的专业属于，</p><h2 id="第一章" tabindex="-1">第一章 <a class="header-anchor" href="#第一章" aria-label="Permalink to &quot;第一章&quot;">​</a></h2><p>JavaScript 没有提供传统面向对象语言中的类式继承，而是通过原型委托的方式来实现对象与对象之间的继承。</p><p>动态类型语言对变量类型的宽容给实际编码带来了很大的灵活性。由于无需进行类型检测， 我们可以尝试调用任何对象的任意方法，而无需去考虑它原本是否被设计为拥有该方法。</p><p>在动态类型语言的面向对象设计中，鸭子类型的概念至关重要。利用鸭子类型的思想，我们 不必借助超类型的帮助，就能轻松地在动态类型语言中实现一个原则：“面向接口编程，而不是 面向实现编程”。例如，一个对象若有 push 和 pop 方法，并且这些方法提供了正确的实现，它就 可以被当作栈来使用。一个对象如果有 length 属性，也可以依照下标来存取属性（最好还要拥 有 slice 和 splice 等方法），这个对象就可以被当作数组来使用</p><p>多态背后的思想是将“做什么”和“谁去做以及怎样去做”分离开来，也就是将“不变的事 物”与 “可能改变的事物”分离开来。在这个故事中，动物都会叫，这是不变的，但是不同类 型的动物具体怎么叫是可变的。把不变的部分隔离出来，把可变的部分封装起来，这给予了我们 扩展程序的能力，程序看起来是可生长的，也是符合开放—封闭原则的，相对于修改代码来说， 仅仅增加代码就能完成同样的功能，这显然优雅和安全得多。</p><p>写文章思路：</p><ol><li>是什么（概念）？</li><li>怎么使用？</li><li>延伸</li><li>何时使用？使用场景？</li><li>有什么问题？</li></ol><p>几个原则是否要加上？</p><ol><li>开放-封闭原则</li><li>好莱坞原则</li></ol>',11);function _(h,f,m,k,u,v){const e=i("ArticleMetadata");return r(),s("div",null,[n,c(e),d])}const A=t(l,[["render",_]]);export{j as __pageData,A as default};
